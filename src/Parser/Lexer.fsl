{
// Copyright (c) Mobile Ownership, mobileownership.org.  All Rights Reserved.  See LICENSE.txt in the project root for license information.

open System
open System.Text
open FSharp.Text.Lexing
open MobileOwnership.PolicyText.Grammar

let lexeme = LexBuffer<_>.LexemeString

let newline (lexbuf: LexBuffer<_>) = 
    lexbuf.EndPos <- lexbuf.StartPos.NextLine

let tokenInteger (lexbuf: LexBuffer<_>) =
    let i = System.Int64.Parse(lexeme lexbuf)
    INTEGER(i)

let tokenDouble (lexbuf: LexBuffer<_>) =
    let s = lexeme lexbuf
    let d = 
        if s.EndsWith('f') then
            System.Double.Parse(s.Substring(0, s.Length - 1))
        else
            System.Double.Parse(s)
    DOUBLE(d)

let escapeChar(lexbuf: LexBuffer<_>) =
    let s = lexeme lexbuf
    match s with
    | "\\\"" -> '\"'
    | "\\\\" -> '\\'
    | "\\/" -> '/'
    | "\\b" -> '\b'
    | "\\f" -> '\f'
    | "\\n" -> '\n'
    | "\\r" -> '\r'
    | "\\t" -> '\t'
    | _ ->
        let ns = s.Substring(2)
        let i = Convert.ToInt32(ns, 16)
        char(i)

let identOrKeyword (text: string) =
    match text with
    | "false"   -> BOOLEAN(false)
    | "true"    -> BOOLEAN(true)
    | "null"    -> NULL
    | _         -> IDENT(text)

}

let whitespace = [' ''\n''\r''\t']*
let sign = ['+''-']?
let onenine = ['1'-'9']
let digit = ['0'-'9']
let digits = digit+
let exponent = (['E''e'] sign digits)?
let fraction = ('.' digits)?
let integer = digit | (onenine digits) | ('-' digit) | ('-' onenine digits)
let number = integer fraction exponent
let hex = digit | ['A'-'F'] | ['a'-'f']
let escape = '\\' (['\"''\\''/''b''f''n''r''t'] | 'u' hex hex hex hex)
let character = 
    [^
        '\u0000''\u0001''\u0002''\u0003''\u0004''\u0005''\u0006''\u0007'
        '\u0008''\u0009''\u000a''\u000b''\u000c''\u000d''\u000e''\u000f'
        '\u0010''\u0011''\u0012''\u0013''\u0014''\u0015''\u0016''\u0017'
        '\u0018''\u0019''\u001a''\u001b''\u001c''\u001d''\u001e''\u001f'
        '\"''\\'
    ]

let digit_char = ['0'-'9']
let letter_char = '\Lu' | '\Ll' | '\Lt' | '\Lm' | '\Lo' | '\Nl'
let connecting_char = '\Pc'
let combining_char = '\Mn' | '\Mc'
let formatting_char = '\Cf'

let ident_start_char = letter_char | '_'
let ident_char = letter_char | digit_char | connecting_char | combining_char | formatting_char | ['\'' '_']
let ident = ident_start_char ident_char*

rule policy = parse
| ","                           { COMMA }
| ":"                           { COLON }
| "["                           { LBRACKET }
| "]"                           { RBRACKET }
| "{"                           { LBRACE }
| "}"                           { RBRACE }
| '\"'                          { lexString (new StringBuilder()) lexbuf }
| "``"                          { lexIdent (new StringBuilder()) lexbuf }
| integer                       { tokenInteger lexbuf }
| number                        { tokenDouble lexbuf }
| ident                         { identOrKeyword (lexeme lexbuf) }
| whitespace                    { policy lexbuf }
| eof                           { EOF }
| _                             { failwith ("ParseError" + LexBuffer<_>.LexemeString lexbuf) }

and lexString sb = parse
| escape                        { sb.Append(escapeChar lexbuf) |> ignore; lexString sb lexbuf }
| character+                    { sb.Append(lexeme lexbuf) |> ignore; lexString sb lexbuf }
| '\"'                          { STRING (sb.ToString()) }

and lexIdent sb = parse
| ( [^'`' '\n' '\r' '\t'] | '`' [^ '`' '\n' '\r' '\t'] )+
                                { sb.Append(lexeme lexbuf) |> ignore; lexIdent sb lexbuf }
| "``"                          { IDENT (sb.ToString()) }