%{
// Copyright (c) Mobile Ownership, mobileownership.org.  All Rights Reserved.  See LICENSE.txt in the project root for license information.

open System
open MobileOwnership.PolicyText
open MobileOwnership.PolicyText.Actions

%}

%start policyText

%token <string> IDENT
%token <string> STRING
%token <int64> INTEGER
%token <double> DOUBLE 
%token <bool> BOOLEAN
%token NULL COLON LBRACKET RBRACKET LBRACE RBRACE LPAREN RPAREN
%token FUN IF THEN ELSE ELIF BEGIN END LET REC IN MATCH WITH WHEN POLICY TRY FINALLY
%token SEND RECEIVE ON REF 
%token RARROW EQUAL BAR COLON_EQUAL BANG
%token SEMI BAR_SEMI COMMA BAR_COMMA
%token EOF

%type <Value> policyText

%left app 
%right RARROW REF BANG SEMI BAR_SEMI
%nonassoc term_if 
%nonassoc ELSE ELIF
%nonassoc COLON_EQUAL

%%

policyText:
    | term EOF                              { $1 }

term: 
    | sequence                              { $1 }
    | function                              { $1 }
    | if                                    { $1 }
    | let                                   { $1 }
    | match                                 { $1 }
    | policy                                { $1 }
    | tryWith                               { $1 }
    | tryFinally                            { $1 }
    | receive                               { $1 }
    | send                                  { $1 }
    | ref                                   { $1 }
    | dereference                           { $1 }
    | assignment                            { $1 }

sequence:
    | steps                                 { termSequence parseState }

steps:
    | steps sep_semi application            { $3 :: $1 }
    | application                           { [ $1 ] }

application: 
    | application value     %prec app       { termApplication parseState }
    | value                                 { $1 }

function:
    | FUN term RARROW term                  { termFunction parseState }

if:
    | IF value THEN value %prec term_if     { termIf 1 parseState }
    | IF value THEN value ifElse            { termIf 2 parseState }
    
ifElse:
    | ELIF value THEN value %prec term_if   { termIf 3 parseState }
    | ELIF value THEN value ifElse          { termIf 4 parseState }
    | ELSE value                            { $2 }

let:
    | LET value EQUAL value IN term END     { termLet 1 parseState }
    | LET REC value EQUAL value IN term END { termLet 2 parseState }

rules:
    | rules BAR rule                        { $3 :: $1 }
    | rule                                  { [ $1 ] }

rule:
    | value RARROW value                    { termRule 1 parseState }
    | value WHEN value RARROW value         { termRule 2 parseState }

match:
    | MATCH value WITH rules                { termMatch 1 parseState }
    | MATCH value WITH BAR rules            { termMatch 2 parseState }

policy:
    | POLICY value WITH rules               { termPolicy 1 parseState }
    | POLICY value WITH BAR rules           { termPolicy 2 parseState }

receive:
    | RECEIVE ON value WITH rules           { termReceive 1 parseState }
    | RECEIVE ON value WITH BAR rules       { termReceive 2 parseState }

send:
    | SEND value ON value                   { termSend parseState }

tryWith:
    | TRY value WITH rules                  { termTryWith parseState }

tryFinally:
    | TRY value FINALLY value               { termTryFinally parseState }

ref:
    | REF value                             { termRef parseState }

dereference:
    | BANG value                            { termDereference parseState }

assignment:
    | value COLON_EQUAL value               { termAssignment parseState }

value: 
    | lookup                                { $1 }
    | map                                   { $1 } 
    | list                                  { $1 }
    | constant                              { $1 }
    | block                                 { $1 }
    | paren                                 { $1 }

block: 
    | BEGIN term END                        { $2 }

paren:
    | LPAREN term RPAREN                    { $2 }

sep_semi:
    | SEMI                                  { ";" }
    | BAR_SEMI                              { "|;" }

sep_comma:
    | COMMA                                 { "," }
    | BAR_COMMA                             { "|," }

lookup:
    | IDENT                                 { termLookup parseState }

map: 
    | LBRACE RBRACE                         { termMap 1 parseState }
    | LBRACE elements RBRACE                { termMap 2 parseState }

elements:
    | elements sep_comma element            { $3 :: $1 }
    | element                               { [ $1; ] }

element:
    | STRING COLON value                    { ($1, $3) }
    | IDENT COLON value                     { ($1, $3) }

list:
    | LBRACKET RBRACKET                     { termList 1 parseState }
    | LBRACKET items RBRACKET               { termList 2 parseState }
    
items:
    | items sep_comma value                 { $3 :: $1 }
    | value                                 { [ $1; ] }

constant: 
    | STRING                                { Value.String($1) }
    | INTEGER                               { Value.Integer($1) }
    | DOUBLE                                { Value.Double($1) }
    | BOOLEAN                               { Value.Boolean($1) }
    | NULL                                  { Value.Null }
